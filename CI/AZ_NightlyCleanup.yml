# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml

trigger:
- master

pool:
  vmImage: 'vs2017-win2016'

schedules:
  - cron: 0 16 * * *
    displayName: Scheduled NOON cleanup #Remove When Finished#
    branches:
      include:
      - CITesting
    always: true
  - cron: "0 6 * * *"
    displayName: Nightly cleanup
    branches:
     include:
      - CITesting
    always: true
  - cron: "0 8 * * *"
    displayName: Nightly +2h cleanup
    branches:
      include:
      - CITesting
    always: true

variables:
  GetResourceGroupsStatement: 'Get-AzResourceGroup -Tag @{Department="tSQLtCI"; Ephemeral="True"}'


steps:

- task: AzureCLI@2
  name: IdentifyDeletableRGs
  condition: true
  inputs:
    azureSubscription: 'tSQLt CI Subscription(58c04a99-5b92-410c-9e41-10262f68ca80)'
    scriptType: 'ps'
    scriptLocation: 'inlineScript'
    inlineScript: |
      Write-Host '-----------------------------'
      Write-Host 'List RGs to be deleted'
      Write-Host '-----------------------------'
      $RGTBD = ConvertFrom-JSON((az group list --tag "Department=tSQLtCI" --tag "Ephemeral=True")|out-string);
      ## black magic, because this^^^^^^^^^^^^ returns an array of strings that together make a json value -- go figure

      $RGNs = @();
      $RGTBD | ForEach-Object { 
        $isDeletable = true;
        $RBTag = $_.tags.RemovalBy;
        
        ##        if(![string]::isnullorempty($RBTag))
        ##        {
        ##          $isDeletable = false;
        ##          ([powershell]::Create().AddScript("Write-Host (az pipelines runs show --id $RBTag --query 'status')"))|%{$_.Invoke();$Output=$_.Streams;}
        ##          ## more black magic, because "az pipelines" does not produce capturable errors
        ##          $NE="";
        ##          $Output.PSObject.Properties|%{$_.name; $_}
        ##          $Output.Error|ForEach-Object{
        ##            if($_ -match "'pipelines runs' is in preview")
        ##            {write-warning $_}
        ##            elseif($_ -match "The requested build $RBT could not be found.")
        ##            {
        ##              write-host $_;
        ##              $isDeletable = true;
        ##            }
        ##            else
        ##            {$NE+=[Environment]::NewLine+"-->"+$_}
        ##          }
        ##          if($NE -ne ""){throw ("Error(s) encountered inquiring status for buid {0}{1}" -f $RBT,$NE)};
        ##          if(!($Output.Information[0] -match "^.?inProgress.?$"))
        ##          {
        ##            $isDeletable = true;
        ##          }
        ##          if($isDeletable)
        ##          {
        ##            ##remove tag
        ##          }
        ##        }
        
        if($isDeletable)
        {
          ##.      $RGNs += ($_.name);
          write-warning "This ^^^ line should not be commented!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!";
          Write-Host ("{0} added to queue" -f $_.name);
          ConvertFrom-JSON((az group lock list -g $_.name)|out-string)|FT;
        }
        else
        {
          Write-Host ("{0} skipped (RemovalBy {1})" -f $_.name,$RBTag);
        }
        $RGNs += ($_.name); write-warning "This line should not be here!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!";
      }
      Write-Host '-----------------------------'
      Write-Host 'Sleeping for 15 seconds'
      #Start-Sleep -s 15
      Write-Host '-----------------------------'
      Write-Host 'Setting Variable'
      $SerializedListOfRGs=(ConvertTo-JSON -InputObject $RGNs -Compress)
      $SerializedListOfRGs
      Write-Host "##vso[task.setvariable variable=SerializedListOfRGs]$SerializedListOfRGs"
      Write-Host 'Setting Variable Done'


- task: AzurePowerShell@4
  name: print_stuff
  inputs:
    azureSubscription: 'tSQLt CI Subscription(58c04a99-5b92-410c-9e41-10262f68ca80)'
    azurePowerShellVersion: 'LatestVersion'
    failOnStandardError: True
    ScriptType: 'InlineScript'
    Inline: |
      Write-Host '----->' $env:SerializedListOfRGs '<-----'
      $RGTBD = (ConvertFrom-JSON $env:SerializedListOfRGs)
      $RGTBD | FT
      $RGTBD.count;
      Write-Host '-----> List of Running Cleanup Builds <-----'
      #az pipelines runs list --org "https://sqlity.visualstudio.com/" --project "tSQLt CI"



- task: AzurePowerShell@4
  condition: succeeded()
  name: Delete_RGs
  inputs:
    azureSubscription: 'tSQLt CI Subscription(58c04a99-5b92-410c-9e41-10262f68ca80)'
    azurePowerShellVersion: 'LatestVersion'
    FailOnStandardError: true
    ScriptType: 'InlineScript'
    Inline: |
      $RemoveResourceGroup = {
            param($OrgRGN)
            Write-Output "---------------------------------------------------------------------------------------------------------------";
            Write-Output ("[{0}]Start processing delete for {1}" -f ((get-date).toString("O")), ($OrgRGN))
            $MyRG = @(Get-AzResourceGroup) | Where-Object {$_.ResourceGroupName -eq "$OrgRGN" -and $_.Tags.Ephemeral -eq "True" -and $_.Tags.Department -eq "tSQLtCI"} 
            if("RemovalBy" -in $MyRG.Tags.Keys)
            {
              $MyRG = $null;
            }
            if($MyRG -ne $null)
            {
              $Tags = @{};
              Write-Output ("Add Tag to {0}" -f $OrgRGN);
              $Tags = $MyRG.Tags
              $Tags += @{"RemovalBy"="$(Build.BuildId)"}
              $MyRG|Set-AzResourceGroup -Tags $Tags
              Start-Sleep 10
              Write-Output ("Confirming Tags are still in place for {0}" -f $OrgRGN)
              $MyRG = $MyRG|Get-AZResourceGroup| Where-Object {$_.Tags.RemovalBy -eq "$(Build.BuildId)"}
              $MyRG.Tags|FT
              if($MyRG -ne $null)
              {
                Write-Output "Removing Locks"
                Get-AzResource -ResourceGroupName $MyRG.ResourceGroupName |ForEach{
                  Get-AzResourceLock -ResourceType $_.ResourceType -ResourceName $_.Name -ResourceGroupName $_.ResourceGroupName|ForEach{
                    Write-Output ("{0} -> {1}" -f $_.ResourceType, $_.ResourceName);
                    $_ | Remove-AzResourceLock -Force 
                  }
                }
                Write-Output ("Removing RG {0}" -f $OrgRGN);
                $MyRG | Remove-AzResourceGroup -Force 
              }
              else
              {
                Write-Output "Tags where changed by other thread"
              }
            }        
            else
            {
              Write-Output "processing skipped"
            }
            Write-Output ("[{0}]Done processing delete for {1}" -f ((get-date).toString("O")), ($OrgRGN))
            Write-Output "---------------------------------------------------------------------------------------------------------------";
      }
      $ThreadHash = @{};
      $RGs = (ConvertFrom-JSON $env:SerializedListOfRGs);
      Write-Host ("Deleting {0} ResourceGroups" -f $RGs.count)
      $RunspacePool = [runspacefactory]::CreateRunspacePool(1,$RGs.count)
      $RunspacePool.open()
      $RGs | ForEach-Object { 
          $ResourceGroupName = $_;
          Write-Host "===================================================================================================================";
          Write-Host ("Deleting ResourceGroup {0}" -f $ResourceGroupName)
          if($ResourceGroupName -ne $null)
          {
            Write-Host ("BeginInvoke RemoveResourceGroup({0})" -f $ResourceGroupName);
            $PSInstance = [powershell]::Create().AddScript($RemoveResourceGroup).AddArgument($ResourceGroupName);
            $PSinstance.RunspacePool = $RunspacePool;
            $Handle = $PSInstance.BeginInvoke();
            $ThreadHash.Add($ResourceGroupName,@{PSInstance=$PSInstance;Handle=$Handle})
          }else{
            Write-Host "Skipped...";
          }
          Write-Host ("Done BeginInvoke for ResourceGroup({0})" -f $ResourceGroupName);
          Write-Host "===================================================================================================================";
      }
      $ThreadHash.GetEnumerator() | ForEach-Object{
          Write-Host ":::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::";
          Write-Host ("EndInvoke RemoveResourceGroup({0})" -f $_.Key);
          $PsInstance = $_.Value.PsInstance;
          $PSInstance.EndInvoke($_.Value.Handle);
          $PSInstance.Streams;
          Write-Host ("Done RemoveResourceGroup({0})" -f $_.Key);
          Write-Host ":::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::";
      }
      #Start-Job -InputObject $_ -ScriptBlock { } 
      #Get-AzResourceGroup -Tag @{Department="tSQLtCI"; Ephemeral="True"} | ForEach-Object { $_ | Remove-AzResourceGroup -Force } 
